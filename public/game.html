<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trivia Game</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://bundle.run/buffer@6.0.3"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>
    <style>
        .non-copyable {
            user-select: none;
        }
        .correct {
            background-color: #90EE90 !important;
            transition: background-color 0.3s ease;
        }
        .incorrect {
            background-color: #FFB6C1 !important;
            transition: background-color 0.3s ease;
        }
    </style>
    <script>
        const splToken = window.SplToken;
        
        // Initialize Buffer from polyfill
        window.Buffer = buffer.Buffer;
        
        const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
        const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
        const USDC_DECIMALS = 6;

        const config = {
            USDC_MINT: new solanaWeb3.PublicKey('Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr'),
            TREASURY_WALLET: new solanaWeb3.PublicKey('GN6uUVKuijj15ULm3X954mQTKEzur9jxXdRRuLeMqmgH'),
            HOUSE_FEE_PERCENT: 2.5,
            MIN_BET_AMOUNT: 1,
            MAX_BET_AMOUNT: 100
        };

        const connection = new solanaWeb3.Connection(
            'https://api.devnet.solana.com',
            'confirmed'
        );

    </script>
</head>
<body>
    <header>
        <h1>Brainy Battle Quiz</h1>
        <button onclick="toggleTheme()">Toggle Theme</button>
        <button id="connectWalletBtn" onclick="connectWallet()">Connect Wallet</button>
        <div id="walletStatus"></div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="leaderboard.html">Leaderboard</a></li>
            </ul>
        </nav>
    </header>

    <div class="container" id="gameContainer">
        <h1>Trivia Game</h1>
        <div id="balanceDisplay"></div>
        <div id="countdownTimer"></div>
        <div id="gameArea">
            <select id="betAmount">
                <option value="3">3 USDC Game</option>
                <option value="10">10 USDC Game</option>
                <option value="15">15 USDC Game</option>
                <option value="20">20 USDC Game</option>
                <option value="30">30 USDC Game</option>
            </select>
            <button id="joinGameBtn" type="button">Join Game</button>
            <div id="waitingMessage"></div>
            <div id="players"></div>
            <div id="question" class="non-copyable"></div>
            <div id="options"></div>
            <button id="submitAnswer" style="display:none;">Submit Answer</button>
            <button onclick="showLeaderboard()">Show Leaderboard</button>
            <button id="inviteFriendsBtn">Invite Friends</button>
        </div>
        <div id="leaderboardContainer">
            <h2>Leaderboard</h2>
            <table id="leaderboardTable">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Username</th>
                        <th>Correct Answers</th>
                        <th>Games Played</th>
                        <th>Total Points</th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody"></tbody>
            </table>
        </div>
    </div>

    <div id="notification" style="display: none; background-color: #f0f0f0; padding: 10px; margin: 10px 0;"></div>
    <audio id="joinSound" src="assets/button-7.mp3" preload="auto"></audio>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script>
        const socket = io();
        let connectedWallet = null;
        let currentRoomId = null;
        let questionStartTime;
        let questionTimer;
        let correctAnswer;
        let loggedInUser = null;
        let phantomProvider = null;

        const joinGameBtn = document.getElementById('joinGameBtn');
        const waitingMessage = document.getElementById('waitingMessage');
        const playersDiv = document.getElementById('players');
        const questionDiv = document.getElementById('question');
        const optionsDiv = document.getElementById('options');
        const submitAnswerBtn = document.getElementById('submitAnswer');
        const countdownTimer = document.getElementById('countdownTimer');
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const leaderboardBody = document.getElementById('leaderboardBody');

        let countdownInterval;
        let virtualBalance = 0;

        function getUrlParameter(name) {
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        };

        // Get wallet from URL parameter or localStorage
        const sessionData = localStorage.getItem('sessionData');
        connectedWallet = getUrlParameter('wallet') || (sessionData ? JSON.parse(sessionData).walletAddress : null);

        if (!connectedWallet) {
            console.log('No wallet found in session or URL');
            alert('No wallet connected. Redirecting to login page.');
            window.location.href = 'login.html';
        } else {
            console.log('Wallet connected:', connectedWallet);
            // Initialize the game with the connected wallet
            updateBalance();
        }

        async function updateBalance() {
            try {
                const response = await fetch(`/api/balance/${connectedWallet}`);
                const data = await response.json();
                if (data.balance !== undefined) {
                    virtualBalance = data.balance;
                    document.getElementById('balanceDisplay').textContent = 
                        `Balance: $${virtualBalance.toFixed(2)}`;
                    
                    // Update session data with new balance
                    const sessionData = JSON.parse(localStorage.getItem('sessionData'));
                    sessionData.virtualBalance = virtualBalance;
                    localStorage.setItem('sessionData', JSON.stringify(sessionData));
                }
            } catch (error) {
                console.error('Error fetching balance:', error);
            }
        }

        async function connectWallet() {
            try {
                // Check if Phantom is installed
                if (window.solana && window.solana.isPhantom) {
                    phantomProvider = window.solana;
                } else {
                    alert('Phantom wallet is not installed. Please install it from https://phantom.app/');
                    window.open('https://phantom.app/', '_blank');
                    return;
                }

                // Connect to wallet
                const response = await phantomProvider.connect();
                connectedWallet = response.publicKey.toString();
                console.log('Connected to wallet:', connectedWallet);

                // Save wallet connection
                localStorage.setItem('walletAddress', connectedWallet);

                // Update UI to show connected state
                updateWalletStatus();
                updateBalance();
                
                return connectedWallet;
            } catch (err) {
                console.error('Error connecting to wallet:', err);
                alert('Failed to connect wallet: ' + err.message);
            }
        }

        function updateWalletStatus() {
            if (connectedWallet) {
                // Update UI to show connected wallet
                const shortAddress = `${connectedWallet.slice(0, 4)}...${connectedWallet.slice(-4)}`;
                document.getElementById('walletStatus').textContent = `Connected: ${shortAddress}`;
            }
        }

        // Check wallet connection on page load
        window.addEventListener('load', async () => {
            try {
                if (!window.solana || !window.solana.isPhantom) {
                    throw new Error('Phantom wallet not installed');
                }

                const sessionDataStr = localStorage.getItem('sessionData');
                if (!sessionDataStr) {
                    throw new Error('No session found');
                }

                const sessionData = JSON.parse(sessionDataStr);
                
                if (Date.now() - sessionData.timestamp > 24 * 60 * 60 * 1000) {
                    throw new Error('Session expired');
                }

                let publicKey;
                if (window.solana.isConnected) {
                    publicKey = window.solana.publicKey.toString();
                } else {
                    const resp = await window.solana.connect({ onlyIfTrusted: true });
                    publicKey = resp.publicKey.toString();
                }

                if (publicKey !== sessionData.walletAddress) {
                    throw new Error('Wallet mismatch');
                }

                connectedWallet = publicKey;
                console.log('Session restored:', connectedWallet);
                
                document.getElementById('walletStatus').textContent = 
                    `Connected: ${connectedWallet.slice(0,4)}...${connectedWallet.slice(-4)}`;
                
                socket.emit('walletReconnect', connectedWallet);
                updateBalance();

            } catch (error) {
                console.error('Session validation failed:', error);
                localStorage.removeItem('sessionData');
                window.location.href = 'login.html';
            }
        });

        window.solana?.on('disconnect', () => {
            console.log('Wallet disconnected');
            localStorage.removeItem('sessionData');
            window.location.href = 'login.html';
        });

        // Add helper functions at the top of your script section
        async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
            return (await solanaWeb3.PublicKey.findProgramAddress(
                [
                    walletAddress.toBuffer(),
                    TOKEN_PROGRAM_ID.toBuffer(),
                    tokenMintAddress.toBuffer(),
                ],
                ASSOCIATED_TOKEN_PROGRAM_ID
            ))[0];
        }

        function updateUIForJoining() {
            joinGameBtn.disabled = true;
            joinGameBtn.textContent = 'Processing...';
            waitingMessage.textContent = 'Processing USDC payment...';
        }

        function resetJoinUI() {
            joinGameBtn.disabled = false;
            joinGameBtn.textContent = 'Join Game';
            waitingMessage.textContent = '';
        }

        class USDCManager {
            constructor(connection) {
                this.connection = connection;
                this.usdcMint = config.USDC_MINT;
            }

            async findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
                return (await solanaWeb3.PublicKey.findProgramAddress(
                    [
                        walletAddress.toBuffer(),
                        TOKEN_PROGRAM_ID.toBuffer(),
                        tokenMintAddress.toBuffer(),
                    ],
                    ASSOCIATED_TOKEN_PROGRAM_ID
                ))[0];
            }

            async getOrCreateAssociatedTokenAccount(walletPublicKey) {
                try {
                    const tokenAccount = await this.findAssociatedTokenAddress(
                        walletPublicKey,
                        this.usdcMint
                    );

                    try {
                        // Check if account exists
                        const accountInfo = await this.connection.getAccountInfo(tokenAccount);
                        if (accountInfo) {
                            return { tokenAccount, transaction: null };
                        }
                    } catch (error) {
                        console.log('Error checking account:', error);
                    }

                    // Create new account if it doesn't exist
                    console.log('Creating new associated token account...');
                    const transaction = new solanaWeb3.Transaction().add(
                        this.createAssociatedTokenAccountInstruction(
                            walletPublicKey,
                            tokenAccount,
                            walletPublicKey,
                            this.usdcMint
                        )
                    );

                    transaction.recentBlockhash = (await this.connection.getRecentBlockhash()).blockhash;
                    transaction.feePayer = walletPublicKey;

                    return { tokenAccount, transaction };
                } catch (error) {
                    console.error('Error in getOrCreateAssociatedTokenAccount:', error);
                    throw error;
                }
            }

            createAssociatedTokenAccountInstruction(
                payer,
                associatedToken,
                owner,
                mint
            ) {
                const keys = [
                    { pubkey: payer, isSigner: true, isWritable: true },
                    { pubkey: associatedToken, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: false, isWritable: false },
                    { pubkey: mint, isSigner: false, isWritable: false },
                    { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                    { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
                ];

                return new solanaWeb3.TransactionInstruction({
                    keys,
                    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                    data: Buffer.from([])
                });
            }

            async getUSDCBalance(walletAddress) {
                try {
                    const walletPublicKey = new solanaWeb3.PublicKey(walletAddress);
                    const { tokenAccount, transaction } = await this.getOrCreateAssociatedTokenAccount(walletPublicKey);

                    if (transaction) {
                        return {
                            balance: 0,
                            needsTokenAccount: true,
                            createAccountTransaction: transaction
                        };
                    }

                    const accountInfo = await this.connection.getAccountInfo(tokenAccount);
                    const balance = accountInfo ? accountInfo.lamports / Math.pow(10, 6) : 0;

                    return {
                        balance,
                        needsTokenAccount: false
                    };
                } catch (error) {
                    console.error('Error getting USDC balance:', error);
                    throw error;
                }
            }

            async createTransferTransaction(walletAddress, betAmount) {
                try {
                    if (betAmount < config.MIN_BET_AMOUNT || betAmount > config.MAX_BET_AMOUNT) {
                        throw new Error(`Bet amount must be between ${config.MIN_BET_AMOUNT} and ${config.MAX_BET_AMOUNT} USDC`);
                    }

                    const fromWallet = new solanaWeb3.PublicKey(walletAddress);
                    
                    // Get token accounts
                    const { tokenAccount: fromTokenAccount, transaction: createFromAcctTx } = 
                        await this.getOrCreateAssociatedTokenAccount(fromWallet);
                    const { tokenAccount: toTokenAccount, transaction: createToAcctTx } = 
                        await this.getOrCreateAssociatedTokenAccount(config.TREASURY_WALLET);

                    // Create transfer instruction
                    const transferInstruction = new solanaWeb3.TransactionInstruction({
                        keys: [
                            { pubkey: fromTokenAccount, isSigner: false, isWritable: true },
                            { pubkey: toTokenAccount, isSigner: false, isWritable: true },
                            { pubkey: fromWallet, isSigner: true, isWritable: false },
                        ],
                        programId: TOKEN_PROGRAM_ID,
                        data: Buffer.from([3, ...new Uint8Array(8).fill(betAmount * 1000000)])
                    });

                    // Create transaction and add all necessary instructions
                    const transaction = new solanaWeb3.Transaction();
                    if (createFromAcctTx) transaction.add(createFromAcctTx);
                    if (createToAcctTx) transaction.add(createToAcctTx);
                    transaction.add(transferInstruction);

                    const { blockhash } = await this.connection.getRecentBlockhash();
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = fromWallet;

                    return transaction;
                } catch (error) {
                    console.error('Error creating transfer transaction:', error);
                    throw error;
                }
            }
        }

        // Initialize USDC manager after connection is created
        const usdcManager = new USDCManager(connection);

        // Update the USDC payment section in the joinGameBtn event listener
        joinGameBtn.addEventListener('click', async () => {
            try {
                if (!connectedWallet || !window.solana?.isConnected) {
                    alert('Please connect your wallet first');
                    return;
                }

                const betAmount = parseInt(document.getElementById('betAmount').value);
                updateUIForJoining();

                // Check USDC balance and create token account if needed
                const balanceResult = await usdcManager.getUSDCBalance(connectedWallet);
                
                if (balanceResult.needsTokenAccount) {
                    console.log('Creating token account...');
                    const signed = await window.solana.signTransaction(balanceResult.createAccountTransaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);
                }

                if (balanceResult.balance < betAmount) {
                    throw new Error(`Insufficient USDC balance. You have ${balanceResult.balance} USDC`);
                }

                // Create and send bet transaction
                console.log('Creating bet transaction...');
                const transaction = await usdcManager.createTransferTransaction(connectedWallet, betAmount);
                console.log('Requesting transaction signature...');
                const signed = await window.solana.signTransaction(transaction);
                console.log('Sending transaction...');
                const txSignature = await connection.sendRawTransaction(signed.serialize());
                console.log('Confirming transaction...');
                await connection.confirmTransaction(txSignature);

                console.log('USDC transfer successful:', txSignature);

                // Join game
                socket.emit('joinGame', {
                    walletAddress: connectedWallet,
                    betAmount,
                    transactionSignature: txSignature
                });

                joinGameBtn.style.display = 'none';
                waitingMessage.textContent = 'Waiting for another player...';

            } catch (error) {
                console.error('Join game error:', error);
                resetJoinUI();
                alert('Failed to join game: ' + error.message);
            }
        });

        socket.on('balanceUpdate', (newBalance) => {
            virtualBalance = newBalance;
            document.getElementById('balanceDisplay').textContent = `Balance: $${virtualBalance.toFixed(2)}`;
        });

        socket.on('joinGameSuccess', (data) => {
            console.log('Successfully joined game:', data);
            joinGameBtn.style.display = 'none';
            waitingMessage.textContent = 'Waiting for another player...';
        });

        socket.on('joinGameFailure', (error) => {
            console.error('Failed to join game:', error);
            resetJoinUI();
            alert('Failed to join game: ' + error);
        });

        submitAnswerBtn.addEventListener('click', () => {
            const selectedOption = document.querySelector('input[name="answer"]:checked');
            if (selectedOption) {
                const responseTime = moment().diff(moment(questionStartTime), 'milliseconds');
                const selectedAnswer = parseInt(selectedOption.value);
                socket.emit('submitAnswer', { roomId: currentRoomId, answer: selectedAnswer, responseTime, username: connectedWallet });
                submitAnswerBtn.disabled = true;
                waitingMessage.textContent = 'Waiting for other player to answer...';
                
                if (selectedAnswer === correctAnswer) {
                    selectedOption.parentElement.classList.add('correct');
                } else {
                    selectedOption.parentElement.classList.add('incorrect');
                    document.querySelector(`input[value="${correctAnswer}"]`).parentElement.classList.add('correct');
                }
            } else {
                alert('Please select an answer!');
            }
        });

        socket.on('gameJoined', (roomId) => {
            currentRoomId = roomId;
            console.log(`Joined room ${roomId}`);
            waitingMessage.textContent = 'Waiting for another player... (Game will start in single player mode after 30 seconds)';
        });

        socket.on('playerJoined', (username) => {
            waitingMessage.textContent = `${username} joined. Game is starting...`;
        });

        socket.on('gameStart', ({ players, questionCount, singlePlayerMode }) => {
            waitingMessage.textContent = singlePlayerMode ? 
                'No other players found. Starting single player mode...' : 
                'Game started!';
            updatePlayers(players);
        });

        socket.on('nextQuestion', ({ question, options, questionNumber, totalQuestions, questionStartTime: qStartTime, correctAnswerIndex }) => {
            questionStartTime = parseInt(qStartTime);
            correctAnswer = correctAnswerIndex;
            displayQuestion(question, options, questionNumber, totalQuestions);
            submitAnswerBtn.disabled = false;
            submitAnswerBtn.style.display = 'block';
            waitingMessage.textContent = '';
            
            if (questionTimer) {
                clearTimeout(questionTimer);
            }
            
            questionTimer = setTimeout(() => {
                submitAnswerBtn.disabled = true;
                waitingMessage.textContent = 'Time\'s up!';
            }, 7000);
            
            startCountdown(questionStartTime);
        });

        socket.on('scoreUpdate', (players) => {
            updatePlayers(players);
            if (questionTimer) {
                clearTimeout(questionTimer);
            }
        });

        socket.on('gameOver', (data) => {
            console.log('Received game over data:', data);
            const { players, winner, betAmount, winnerBalance, singlePlayerMode } = data;
            
            questionDiv.textContent = 'Game Over!';
            submitAnswerBtn.style.display = 'none';
            
            if (singlePlayerMode) {
                const player = players[0];
                if (winner) {
                    waitingMessage.textContent = `Congratulations! You won with ${player.score} correct answers! You won $${(betAmount * 1.8).toFixed(2)}!`;
                    virtualBalance = winnerBalance;
                } else {
                    waitingMessage.textContent = `Game Over! You got ${player.score} correct answers. You need at least 5 correct answers to win.`;
                }
            } else {
                players.sort((a, b) => b.score - a.score || a.totalResponseTime - b.totalResponseTime);

                if (winner) {
                    const winnerPlayer = players.find(p => p.username === winner);
                    waitingMessage.textContent = `The winner is ${winner} with a score of ${winnerPlayer.score}!`;
                    
                    if (winner === connectedWallet) {
                        const winnings = betAmount ? parseFloat(betAmount) * 1.8 : 0;
                        waitingMessage.textContent += ` You won $${winnings.toFixed(2)}!`;
                        virtualBalance = winnerBalance;
                    } else {
                        waitingMessage.textContent += ` Better luck next time! Thanks for playing!`;
                    }
                } else {
                    if (players[0].score === players[1].score) {
                        if (players[0].totalResponseTime < players[1].totalResponseTime) {
                            waitingMessage.textContent = `It's a draw based on score! ${players[0].username} wins due to faster total response time (${players[0].totalResponseTime}ms vs ${players[1].totalResponseTime}ms).`;
                        } else if (players[0].totalResponseTime > players[1].totalResponseTime) {
                            waitingMessage.textContent = `It's a draw based on score! ${players[1].username} wins due to faster total response time (${players[1].totalResponseTime}ms vs ${players[0].totalResponseTime}ms).`;
                        } else {
                            waitingMessage.textContent = "It's a perfect draw! Both players had the same score and response time.";
                        }
                        
                        const tiebreakWinner = players[0].totalResponseTime <= players[1].totalResponseTime ? players[0].username : players[1].username;
                        if (tiebreakWinner === connectedWallet) {
                            const winnings = betAmount ? parseFloat(betAmount) * 1.8 : 0;
                            waitingMessage.textContent += ` You won $${winnings.toFixed(2)}!`;
                            virtualBalance = winnerBalance;
                        } else {
                            waitingMessage.textContent += ` Better luck next time!`;
                        }
                    }
                }
            }

            setTimeout(() => {
                document.getElementById('balanceDisplay').textContent = `Balance: $${virtualBalance.toFixed(2)}`;
                
                const scoresHtml = singlePlayerMode ?
                    `<p>${players[0].username}: ${players[0].score} (Total response time: ${players[0].totalResponseTime}ms)</p>` :
                    players.map(p => 
                        `<p>${p.username}: ${p.score} (Total response time: ${p.totalResponseTime}ms)</p>`
                    ).join('');
                
                playersDiv.innerHTML = '<h2>Final Scores:</h2>' + scoresHtml;
                joinGameBtn.style.display = 'inline-block';
                
                optionsDiv.innerHTML = '';
            }, 3000);
        });

        socket.on('playerLeft', (username) => {
            alert(`${username} left the game. The game will end.`);
            resetGame();
        });

        socket.on('updateScores', (players) => {
            updatePlayers(players);
        });

        function displayQuestion(question, options, questionNumber, totalQuestions) {
            questionDiv.innerHTML = `<h2>Question ${questionNumber} of ${totalQuestions}</h2><p>${question}</p>`;
            optionsDiv.innerHTML = options.map((option, index) => `
                <div>
                    <input type="radio" id="option${index}" name="answer" value="${index}">
                    <label for="option${index}">${option}</label>
                </div>
            `).join('');
        }

        function startCountdown(qStartTime) {
            const duration = 7;

            clearInterval(countdownInterval);

            countdownInterval = setInterval(() => {
                const timeRemaining = duration - moment().diff(moment(qStartTime), 'seconds');
                countdownTimer.textContent = `Time remaining: ${timeRemaining} seconds`;

                if (timeRemaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownTimer.textContent = "Time's up!";
                    submitAnswerBtn.disabled = true;
                }
            }, 1000);

            countdownTimer.style.display = 'block';
        }

        function updatePlayers(players) {
            playersDiv.innerHTML = '<h2>Players:</h2>' + players.map(p => 
                `<p>${p.username}: ${p.score} (Total response time: ${p.totalResponseTime || 0}ms)</p>`
            ).join('');
        }

        function resetGame() {
            currentRoomId = null;
            playersDiv.innerHTML = '';
            questionDiv.innerHTML = '';
            optionsDiv.innerHTML = '';
            submitAnswerBtn.style.display = 'none';
            waitingMessage.textContent = '';
            joinGameBtn.style.display = 'block';
            clearInterval(countdownInterval);
            countdownTimer.style.display = 'none';
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
        }

        function showLeaderboard() {
            socket.emit('getLeaderboard');
            leaderboardContainer.style.display = 'block';
        }

        socket.on('leaderboardData', (leaderboard) => {
            leaderboardBody.innerHTML = '';
            leaderboard.forEach((user, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${user.username}</td>
                    <td>${user.correctAnswers}</td>
                    <td>${user.gamesPlayed}</td>
                    <td>${user.totalPoints}</td>
                `;
                leaderboardBody.appendChild(row);
            });
        });

        socket.on('leaderboardError', (message) => {
            alert(`Error fetching leaderboard: ${message}`);
        });

        document.getElementById('inviteFriendsBtn').addEventListener('click', () => {
            const roomId = currentRoomId;
            const inviteLink = `${window.location.origin}/join?roomId=${roomId}`;
            prompt("Share this link with your friends:", inviteLink);
        });

        const joinSound = document.getElementById('joinSound');
        const notification = document.getElementById('notification');

        socket.on('playerJoined', (username) => {
            notification.textContent = `${username} has joined the lobby!`;
            notification.style.display = 'block';
            joinSound.play();
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        });

        questionDiv.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        socket.on('answerResult', (data) => {
            const { username, isCorrect, correctAnswer } = data;
            if (username === connectedWallet) {
                const selectedOption = document.querySelector('input[name="answer"]:checked');
                if (selectedOption) {
                    selectedOption.parentElement.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
            }
        });

        socket.on('playerAnswered', (username) => {
            waitingMessage.textContent = `${username} has submitted their answer`;
        });

        socket.on('roundComplete', (data) => {
            const { correctAnswer, playerResults } = data;
            const options = document.querySelectorAll('#options input');
            
            // Show correct answer
            options[correctAnswer].parentElement.classList.add('correct');
            
            // Only show the current player's incorrect answer if they were wrong
            const playerResult = playerResults.find(result => result.username === connectedWallet);
            if (playerResult && !playerResult.isCorrect) {
                options[playerResult.answer].parentElement.classList.add('incorrect');
            }
        });
    </script>
</body>
</html>